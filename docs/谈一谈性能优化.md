# 启动速度优化
app 的启动步骤：

1. 加载启动 App
2. App 启动后立即展示一个空白的 Window
3. 创建 App 进程
4. 创建 App 对象
5. 启动 Main Thread
6. 创建启动的 Activity 对象
7. 加载 View
8. 布置屏幕
9. 进行第一次绘制

可以优化的就是 Application 和 Activity 创建以及回调等过程。

加速方向：

1. 利用提前展示出来的 Window，快速展示出一个界面，给用户快速反馈的体验
2. 避免在启动的时候做密集沉重的初始化
3. 定位问题，避免I/O操作，反序列化，网络操作，布局嵌套等。


Application 优化：
比如我们在 Application 中集成了推送sdk，埋点sdk，EventBus，热修复，文件操作初始化等第三方组件。

1. 考虑异步初始化第三方组件，不阻塞主线程
2. 延时部分第三方组件初始化
3. 利用闪屏页停留时长

定位耗时一般使用 BlockCanary 或者 ANRWatchDog，方法耗时使用AOP切片代码注入打印时间。
经分析，发现有几个地方引起卡顿：

1. Applocation 中部分第三方库的初始化阻塞了，比如内部创建了线程池，数据库操作等
2. 在MainActivity 里面有大量的网络请求操作和数据库操作
3. 每次都请求，没有做缓存，比如闪屏页，一些配置信息等
4. 首页布局嵌套太多
5. 因为版本迭代的原因，执行了一些已经没用的老逻辑
6. 有一些相同功能的组件一起初始化了，比如网络，图片等

放在异步线程中使用 HandlerThread 而不用线程池，因为线程池开销比 Thread 大。

# 布局优化
**60帧每秒是目前最合适的图像显示速度**，事实上绝大多数的Android设备也是按照每秒60帧来刷新的。为了让屏幕的刷新帧率达到60fps，我们需要**确保在时间16ms（1000/60Hz）内完成单次刷新的操作**（包括measure、layout以及draw）

过渡绘制检测
在开发者选项里面打开调试 GPU 过渡绘制，如果是红色或者粉色的地方说明绘制了多次，可以看下有没有优化的空间。

1. 减少布局的嵌套和控件的个数，可以减少View的绘制时间，主要优化的方式是选择合适的布局，比如约束布局等。
2. 一些布局的背景重复设置了。

# 内存优化
对于 Java 对象来说，内存泄露就是 new 出来的 Object 放在 Heap 上无法被 GC 回收（内存中存在无法回收的对象）

检测：
利用 Android Studio 自带的工具 Menory Monitor，观察内存曲线，手动触发 GC，获取当前堆栈信息分析等。
利用 LeakCanary 检测。

内存抖动：
大量的对象创建后又在短时间内发生被释放，频繁GC。常见引发内存抖动的情形有：循环中创建临时对象，onDraw 中创建 Paint 或者 Bitmap 对象等。

1. 除非有必要，否则不要让 Service 一直运行在后台，最好只有执行任务时才被触发，否则其他时候应该在停止状态。使用完毕后记得要停止，避免内存泄露。
2. 使用优化过的集合，比如 SparseArray，ArrayMap 等。
3. 合理使用弱引用，软引用等。
4. 使用的资源要关闭或者移除，比如数据库，文件，服务，广播，监听器等。
5. 尽量使用静态内部类或者不要使用内部类。


# Bitmap 优化

一张图片的内存占用 = 长 * 宽 * 单位像素大的大小。

bitmap 的优化方向有两个：压缩 和 复用。

Bitmap.Config用来描述图片的像素是怎么被存储的？

**ARGB_8888**       每个像素 4 字节，共 32 位，默认设置
**Alpha_8**            只保存透明度，共 8 位，1 字节 
**ARGB_4444     ** 共16位，2字节
**RGB_565         ** 共16位，2字节，只存储RGB值

A表示透明度，RGB表示颜色。

合理的选用 ARGB_8888 或者 RGB_555 有助于 bitmap 的大小。

bitmap 的复用一般使用 LruCache 和 DiskLruCache 做内存和磁盘缓存。

**bitmap 的压缩：**

**Bitmap.compress() 质量压缩**
质量压缩是在保持像素的前提下改变图片的位深及透明度等来达到压缩目的。不会减少图片像素，经过压缩的图片文件大小会变小，但解码成 bitmap 后占得内存不变。

**BitmapFactory.Options.isSampleSize 内存压缩**
解码图片时，设置 BitmapFactory.Options 类的 inJustDecodeBounds 属性位 true，可以在 Bitmap 不被加到内存时，获取 Bitmap 的原始宽高，而设置 inSampleSize 属性可以真实压缩 Bitmap 占用内存。
# 
**设置 inSmapleSize 后，Bitmap 的宽高都会缩小 inSmapleSize 倍。**
**
例如：一张宽高为 2048x1536 的图片，设置 inSampleSize 为 4 之后，实际加载到内存中的图片宽高是512x384。占有的内存就是 0.75M 而不是 12M，足足节省了 15 倍。

对应的开源库有 luban ，他就是通过一些列算法算出合适的 inSmapleSize 值来达到压缩效果的。

# 卡顿优化
引起卡顿的操作一般有：

1. UI 线程中有耗时操作，比如读写操作，数据库访问操作。
2. 复杂，不合理的布局以及重绘操作，控件越多，嵌套越深，会导致布局花费的时间增加，性能就越差。
3. 复杂重绘是，避免创建临时变量，避免做过多的循环操作等。
4. 内存使用异常引起的卡顿，比如内存抖动，内存泄露等，GC 的次数越多，消耗在GC上的时间就越长，CPU花在界面绘制上的时间相应就越短。

检测卡顿的工具有  BlockCanary 或者 ANRWatchDog。

BlockCanary 的原理是利用 Looper.loop() 方法里面，handler 执行 dispatchMessage 方法的前后的 log 打印，利用前后打印的时间，如果在一个阀值内 Message 没有完成分发，就可以任务存在卡顿。

ANRWatchDog 的原理是开启一个线程，循环不断的往主线程中 post 一个 runnable 来修改一个值的大小，在规定时间后检测这个 Runnable 是否被执行，也就是检测值是否有改变，没有的话则说明主线程在执行上一个 Message 时超时。

解决方法：

1. 把耗时操作移到异步中处理。
2. 合理分配内存，减少频繁 GC
3. 合理优化布局，比较 OverDraw

# 网络优化
网络优化主要从三个方面进行： 速度，成功率，流量

1. Gzip 压缩

HTTP 协议上的 Gzip 编码是一种用来改进WEB应用程序性能的技术，用来减少传输数据量大小，减少传输数据量大小有两个明显的好处：**可以减少流量消耗；可以减少传输的时间。**

2. IP 直连与 HttpDns

**DNS解析的失败率占联网失败中很大一种，而且首次域名解析一般需要几百毫秒。针对此，我们可以不用域名，才用IP直连省去 DNS 解析过程，节省这部分时间。**
**
另外熟悉阿里云的小伙伴肯定知道HttpDns：HttpDNS 基于 Http 协议的域名解析，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免Local DNS造成的域名劫持和跨网访问问题，解决域名解析异常带来的困扰。
 

3. 图片下载和上传

图片下载：图片使用 webp 格式可以大幅度节省流量，因为 webp 格式比较小。使用缩略图，需要的时候才去加载原图，可以节省流量和内存。

图片上传：可以采用分片传输，压缩后上传等

使用网络缓存，连接复用等方式优化，利用返回码去做重试策略等，避免客户端轮询，使用服务端推送方式。

# 安装包大小优化

优化方向：

1. 代码部分：冗余代码，无用功能，代码混淆，方法数缩减等
2. 资源部分：冗余资源，资源混淆，图片处理
3. so 文件处理。

代码优化就是取出无用代码和功能，利用合理的结构简化代码，目的是减少 dex 的体积，避免使用功能相同的库，移除没用的库，避免一个轮子多套实现，比如网络框架，图片框架等。
移除无用资源，对图片资源使用合理的格式，压缩等，对 drawable 中的资源，存在多套，重复等现象，可以利用  LayoutInflater.Factory 接口实现动态生成。资源加载可以利用网络加载的形式，把资源放在服务器。














