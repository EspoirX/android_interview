# 1.jvm内存模型？
JVM 主要组成：

1. 类加载器（ClassLoader）
2. 运行时数据区（Runtime Data Area）
3. 执行引擎（Execution Interface）
4. 本地库接口

其中**运行时数据区**有 5 个部分组成：堆，虚拟机栈，本地方法栈，程序计数器，方法区。

![jvm.png](https://s2.loli.net/2023/06/19/1ZN8Lj2i3e9wMba.png)

1. 程序执行之前要先把 java 代码转成字节码（class文件），JVM 首先需要吧字节码通过 **类加载器（ClassLoader）**把文件加载到 **运行时数据区（内存）**中。
2. 而字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，所以需要特定的命令解析器 **执行引擎** 将字节码翻译成底层系统指令再交给 CPU 去执行。
3. 而这个过程中需要调用其他语言的接口 **本地库接口 **来实现整个程序的功能。

**总结：类加载器将 Java 文件转成字节码，通过类加载器加载到运行时数据区（内存）中，执行引擎将字节码翻译成底层系统指令，翻译过程需要调用本地库接口来实现整个程序功能。**

## 运行时数据区
### 1. 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。再虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，转跳，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成

**特点：内存私有**，由于jvm的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。**因此为了线程切换后能恢复到正确的执行位置，每个线程都有独立的程序计数器。**

### 2. 虚拟机栈
虚拟机栈是 Java 方法执行的内存模型。每个方法再执行的同时都会创建一个**栈帧**，把栈帧压入栈。当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。

- 栈帧存储着方法的相关信息，包含局部变量表，操作数栈，动态链接，方法出入口等。
1. 如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 **StackOverflowError** 异常。
2. 如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 **OutOfMemoryError** 异常。

**特点：内存私有，它里面的对象的生命周期和线程相同。**

### 3. 本地方法栈
与虚拟机栈的作用一样，区别在于虚拟机栈是服务 Java 方法，**而本地方法栈是为虚拟机调用 Native 方法服务的。**  
**特点与异常：与 Java 虚拟机栈相同。**
 
### 4. 堆
**堆是 Java 对象存储的地方。**堆是 Java 虚拟机中内存最大的一块。是被所有哦线程共享的。在虚拟机启动的时候，堆的唯一目的就是存放对象实例，几乎所有对象实例都哦在这里分配。  
**特点：内存共享**

- 如果堆中没有哦内存完成实例分配，并且堆不可以再扩展时，就会抛出 **OutOfMemoryError**  

### 5. 方法区
方法区用于存储**已经被虚拟机加载的类信息，常量，静态变量**，即编译后的代码等数据。  
**特点：内存共享**

- 当方法无法满足内存分配需求时会抛出 **OutOfMemoryError。**


# 2.Java的虚拟机和android 的dalvik、art的区别？
Dalvik 是 Google 公司自己设计用于 Android 平台的虚拟机。是基于Apache的 java 虚拟机。  
ART 即 Android Runtime，Android 4.4发布了一个ART运行时，准备用来替换掉之前一直使用的 Dalvik 虚拟机。  

## 1. Java虚拟机与 Dalvik 的区别

- Java 虚拟机基于栈，基于栈的机器必须使用指令来载入和操作栈上的数据。Dalvik 虚拟机基于寄存器。
- Java 虚拟机运行的是字节码（class文件），Dalvik 运行的是自己专属的 **.dex** 字节码格式。
- Java 虚拟机运行的时候为每一个类装载字节码，Dalvik 程序只包含一个 .dex 文件。这个文件包含类程序中的所有类。

## 2. Dalvik 与 ART 区别
在 Dalvik 下，应用每次运行的时候，字节码都需要通过**即时编译器（just in time ，JIT）**转换为机器码，这会拖慢应用的运行效率。而在 ART 环境中，应用在**第一次安装**的时候，字节码就会**预先编译成机器码**，使其成为真正的本地应用。这个过程叫做**预编译（AOT,Ahead-Of-Time）**。这样的话，应用的启动(首次)和执行都会变得更加快速。

- Dalvik 每次都要编译再运行，Art 只会首次启动编译。
- Art 占用空间比 Dalvik 大（原生代码占用的存储空间更大），就是用“空间换时间”。
- Art 减少编译，减少了 CPU 使用频率，使用明显改善电池续航。
- Art 应用启动更快、运行更快、体验更流畅、触感反馈更及时。



# 3.年轻代、老年代的内存分配比例多少？为什么这样分配？

目前常用的商用垃圾收集器都使用的是**分代垃圾回收方式**。  
分代垃圾回收器把内存分为 **新生代** 和 **老年代**

![jvm1.jpeg](https://s2.loli.net/2023/06/19/TV1AeCQ6DU42xhS.png)

**新生代和老年代的内存比例是 1 : 2。**
 
## 1. 年轻代
程序中的大部分对象都符合 朝生夕死 的特效。**所以绝大部分新创建的对象都会存放在新生代。除非是大对象会直接进入老年代。**
 
新生代分为 Eden，Form Survivor，To Survivor 三个区域，默认比例是 8 : 1 : 1。

新生代采用**复制算法**，这样可以更高效的回收内存空间。**因为年轻代每次 GC 都要回收大部分对象**。新生代里面分成一份较大的 Eden 空间和两份较小的 Survivor 空间。**每次只使用 Eden 和其中一块 Survivor 空间，然后垃圾回收的时候，把存活对象放到未使用的 Survivor（划分出from、to）空间中，清空 Eden 和刚才使用过的Survivor 空间。**
 
内存不足时发生 Minor GC。

## 2. 老年代
老年代垃圾回收的频率比新生代低，存放的主要对象是：

1. 新生代对象进过 N 次 GC 晋升到老年代。
2. 大对象直接存储到老年代。

老年代采用 **标记-整理算法**，原因是老年代每次 GC **只会回收少部分对象。**

# 4.什么时候开始垃圾回收？怎么判定对象的生死？

垃圾回收的第一步就是判断对象是否存活，**只有 “死去” 的对象，才会被垃圾回收器所回收。**
## 对象生死判断算法
### 1. 引用计数器算法
给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1 ，与之相反，每当引用失效时减 1 。  
**优点：实现简单，性能高。**  
**缺点：加减处理频繁消耗 CPU 计算，计数器占用很多位浪费空间，最重要的缺点是无法解决循环引用问题。**  
循环引用是指：
```java
ReferenceDemo referenceDemo = new ReferenceDemo();
ReferenceDemo referenceDemo2 = new ReferenceDemo();
referenceDemo.instance = referenceDemo2;
referenceDemo2.instance = referenceDemo;

referenceDemo = null;
referenceDemo2 = null;
System.gc(); // 手动触发垃圾回收
```

### 2. 可达性分析算法
可达性分析算法是主流的分析算法。核心思路是通过一系列的 “GC Roots” 对象作为起点，从这些对象开始往下搜索，搜索所进过的路径称为 “引用链”。  
当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的：

![jvm2.jpeg](https://s2.loli.net/2023/06/19/yl4zWm3ZPF6K8XD.png)

在 Java 中，可作为 GC Roots 对象的有：

- Java 虚拟机栈中的引用对象。（因为在虚拟机栈中的方法是“活着”的，所以能够作为 GC Roots）
- 本地方法栈中 JNI（即 Native 方法）引用对象。
- 方法去中静态常量的引用对象。
- 方法区中常量的引用对象。


## 对象生死与引用关系
无论哪种方法都与对象的“引用”有关，**说明了对象的引用决定了对象的生死。**  
引用分为：**强引用，软引用，弱引用，虚引用**。强度依次递减。

对象不是非生即死的，当空间还足够时，还可以保留这些对象，如果空间不足时，再抛弃这些对象。很多缓存功能的实现也符合这样的场景。

- 强引用在代码中普遍存在，只要强引用还在，垃圾回收器永远不会回收掉引用对象。
- 软引用，当 JVM 认为内存不足时，才会试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。
- 弱引用，被弱引用管理的对象只能生存到下一次垃圾回收发生之前。
- 虚引用，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当这个对象被回收是收到一个系统通知。
 
# 5.一个对象的引用被置为null之后，我还想使用这个对象，可以用什么方法获取？

**在可达性算法中不可达的对象，要真正死亡，至少要经历两次标记过程。**

第一次：在可达性算法分析之后，没有与 GC Roots 相连接的引用链时，会被第一次标记。  
第二次：当前对象有没有重写 finalize() 方法，或者 finalize() 方法已经被调用过。虚拟机认为该对象不可以被救活，因此回收该对象。（finalize() 方法在垃圾回收中的作用是，给该对象一次救活的机会）

**执行 finalize 方法的两个条件：**

1. 重写链 finalize 方法。
2. finalize 方法之前没被调用过，因为对象的 finalize 方法只能被执行一次。

如果满足以上条件，这个对象会放置在 F-Queue 的队列之中，并在稍后由一个虚拟机自建的，低优先级 Finalizer 线程来执行它。

实例代码：

```java
public class FinalizeDemo {
    public static FinalizeDemo Hook = null;
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("执行finalize方法");
        FinalizeDemo.Hook = this;
    }
    public static void main(String[] args) throws InterruptedException {
        Hook = new FinalizeDemo();
        // 第一次拯救
        Hook = null;
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
        // 第二次，代码完全一样
        Hook = null;
        System.gc();
        Thread.sleep(500); // 等待finalize执行
        if (Hook != null) {
            System.out.println("我还活着");
        } else {
            System.out.println("我已经死了");
        }
    }
}
```

运行结果：
> 执行finalize方法
> 我还活着
> 我已经死了


**不建议使用finalize()方法来拯救对象** ，原因如下：
1、对象的finalize()只能执行一次。
2、它的运行代价高昂。
3、不确定性大。
4、无法保证各个对象的调用顺序。

# 6.垃圾回收算法有哪些？
垃圾回收算法有：**标记-清除算法，复制算法，标记-清理算法，分代收集算法**

## 1. 标记-清除算法
标记-清除算法分为“标记”和“清除”两个阶段，首先需要标记出所需要回收的对象，标记完成后统一收集被标记的对象。  
**优点：实现简单**   
**缺点：容易产生不连续的内存碎片**  
![jvm3.jpeg](https://s2.loli.net/2023/06/19/OHCBqbIspkKEAzd.png)
 
## 2. 复制算法
将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。  
**优点：执行效率高，不易产生内存碎片**  
**缺点：空间利用率低，存活对象多的话，效率低下。**  
![jvm4.jpeg](https://s2.loli.net/2023/06/19/2iSYJncolpwagsQ.png)
 
## 3. 标记-整理算法
标记-整理算法采用和标记清除算法一样的对象“标记”，但后续不会对可回收对象进行清理，而是将存活的对象往一端空闲空间移动，然后清理边界以外的内存空间。  
**优点：不容易产生内存碎片；内存利用率高**  
**缺点：存活对象多并且分散的时候，移动次数多效率低下。**  
![jvm5.jpeg](https://s2.loli.net/2023/06/19/RncBq5SbuaFLYfI.png)
 
## 4. 分代收集算法
分代收集算法是目前商用虚拟机采用的算法。把堆分成新生代和老年代。

- **因为新生代每次垃圾回收都要回收大部分对象，所以采用复制算法**。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。
- **由于老年代每次只回收少量的对象，所以使用标记整理算法。**
 
# 7.说说类的加载机制，java 类加载机制和android的一样吗？说说两者之间的区别？

**类加载器就是把类的数据从字节码文件（Class文件）加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。**

类的加载过程：
> (1) 装载：查找和导入Class文件；
> (2) 链接：把类的二进制数据合并到JRE中；
>      (a)校验：检查载入Class文件数据的正确性；
>      (b)准备：给类的静态变量分配存储空间；
>      (c)解析：将符号引用转成直接引用；
> (3) 初始化：对类的静态变量，静态代码块执行初始化操作
> (4) 使用


在虚拟机角度看，只存在两种不同的类加载器：

- 启动类加载器 **BootstrapClassLoader** ，由 C++ 实现，是虚拟机自身的一部分。
- 其他类加载器，由 Java 语言实现，独立于 JVM 外部，全部继承自 ClassLoader。

**Java 类加载器就是 ClassLoader，系统提供了 启动类加载器，扩展类加载器，应用程序类加载器三种加载器。**

android 中的两种类加载器：

都继承于 BaseDexClassLoader，而 BaseDexClassLoader 继承于 ClassLoader。

- **PathClassLoader** 用于加载系统的类和主 dex 中的类
- **DexClassLoader** 用于加载其他类的加载器


# 8. 为什么使用双亲委托机制？可以破坏掉这种机制吗？

**双亲委托模型的工作过程：**
如果一个类加载器收到类类的加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器。只有当父类加载反馈自己无法完成该加载请求（该加载器的搜索范围中没找到对应的类）时，子加载器才会尝试自己去加载。

**为什么使用双亲委托机制？**

1. 避免重复加载，如果已经加载过一次Class，就不需要再次加载，而是先从缓存中直接读取。
2. **要确定某一个类，需要类的全限定名以及加载此类的 ClassLoader 共同确定**，采用双亲委托机制后，对于一些类，无论你程序中有多少个类加载器，这些类都是共享的，避免类不同的类加载器加载来了同样in 工资的不同类以后造成混乱。

可以破坏该机制：
1. 重写 loadClass 方法，加入自己的逻辑。

# 9. Java内存模型

1. Java 内存模型中规定了所有的变量都存储在主内存中。
2. 每个线程还有自己的工作内存（类比缓存理解），线程的工作内存中保存了该线程使用到主内存中的变量拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。
3. 不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递（通信）均需要在主内存来完成，线程、主内存和工作内存的交互


![jvm6.jpeg](https://s2.loli.net/2023/06/19/7VktdO9ynYN12qG.jpg)


这个图和 CPU 与缓存的图非常类似，搞不好 JMM 的构建就是仿照硬件系统来的。同样的道理我们要思考一下在多线程的环境中，JMM 又是如何保证主内存和工作内存中的变量一致性？回忆一下 CPU 是如何保证缓存一致性的，使用 MESI 协议。那在这里呢，Java 内存模型就定义了 8 种操作和 8 个规则。

回头想想，JMM 是一套规则呀，它只会给你定义规范，模型，具体的实现自己玩去！理解这一点很重要。我们来看看它给出了哪些操作和必须满足的规则吧。

![jvm7.jpeg](https://s2.loli.net/2023/06/19/vKbZidLQ4hglEHR.jpg)


lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的 load 动作使用

load（载入）：作用于工作内存的变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。

use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的 write 的操作。

write（写入）：作用于主内存的变量，它把 store 操作从工作内存中一个变量的值传送到主内存的变量中。










